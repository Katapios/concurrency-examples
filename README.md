# Ветка "reentrant-lock"
## "Блокировки, доступ к общему ресурсу из разных потоков"

### Что реалезовано в данной ветке:
В приведенном ниже примере программы демонстрируется реализация "замков" класс ReentrantLock,
реализующий интерфейс Lock. Прежде чем получить доступ к общему ресурсу, запрашивается
блокировка, защищающая этот ресурс. По завершении доступа к ресурсу блокировка
снимается. Если один поток исполнения попытается запросить блокировку в тот
момент, когда она используется каким-нибудь другим потоком исполнения, то первый
поток будет ожидать до тех пор, пока блокировка не будет снята. Благодаря
этому удается избежать конфликтов при доступе к общему ресурсу.

### Особенности реализации:
#### :warning: Подобным образом можно организовать работу банкомата, где перед снятием и внесением наличных разными людьми (потоками) будет проверяться состояние счета.
- В классе "main" создается экземпляр замка "ReentrantLock", затем 2 экземпляра потока, в конструктор которых передается замок.
- Класс "shared" имитирует общий ресурс в котором инициализируется нулевой счетчик.
- В классе "LockThread" создается обычный поток.
- Конструктор класса "LockThread" принимает в качестве параметра замок и имя потока.
- В методе "run" потоки стартуют, затем первый зашедший поток ожидает блокировки, ставит ее и только потом меняет значение счетчика.
- Первый поток уходит в ожидание и засыпает.
- Первый поток снимает блокировку в обязательном блоке "finally".
- Стартует второй поток(это необязательно. Потоки могут стартовать в другом порядке или, например оба в начале программы).
- Второй поток ожидает блокировки сразу после старта, как только первый поток снимет блокировку, второй поток ее захватит, зайдет и сменит значение счетчика.



**********************************************************************

:warning: **Не скупимся на звездочки на github, форкаем, даем советы по улучшению и оптимизации (всегда рад).**
