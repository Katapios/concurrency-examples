# Ветка "dead-lock"
## "Реализация взаимной блокировки deadlock"

### Что реалезовано в данной ветке:
Следует избегать особого типа ошибок, имеющего отношение к многозадачности
и называемого взаuмной блокировкой, которая происходит в том случае, когда потоки
исполнения имеют циклическую зависимость от пары синхронизированных объектов.
Допустим, один поток исполнения входит в монитор объекта Х, а другой - в мо­нитор объекта У.
Если поток исполнения в объекте Х попытается вызвать любой синхронизированный
метод для объекта У, он будет блокирован, как и предполагалось.
Но если поток исполнения в объекте У, в свою очередь, попытается вызвать любой
синхронизированный метод для объекта Х, то этот поток будет ожидать вечно, по­
скольку для получения доступа к объекту Х он должен снять свою блокировку с объекта
У, чтобы первый поток исполнения мог завершиться.

### Особенности реализации:
#### :warning: Разумеется данной ситуации следует избегать

- Создаются два класса, А и В, с методами foo() и bar() соответственно.
- Оба метода приостанавливаются непосредственно перед попыткой вызова метода из другого класса. 
- Сначала в главном классе Deadlock получаются экземпляры классов А и В, 
- Затем запускается второй поток исполнения, в котором устанавливается состояние взаимной блокировки.
- В методах foo() и bar() используется метод sleep(), чтобы стимулировать появление
взаимной блокировки.

:warning: Исправить данную ситуацию можно, например убрав вызов метода foo() из котструктора класса Deadlock, и переместить его в метод run().

**********************************************************************

:warning: **Не скупимся на звездочки на github, форкаем, даем советы по улучшению и оптимизации (всегда рад).**
