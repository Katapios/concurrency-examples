# Ветка "monitor-synchronization"
## "Реализация классической синхронизации по монитору"

### Что реалезовано в данной ветке:
Иногда требуется синхронизировать доступ к объектам
класса, не предназначенного для многопоточного доступа в нашем случае класс "CallMe". В данном
классе не используются синхронизированные методы. Возможно, класс написан
сторонним разработчиком, и его исходный код недоступен, а следовательно,
в объявление соответствующих методов данного класса нельзя ввести модификатор
доступа synchronized. Но мы можем загрузить данный класс по сети и вызвать его метод заключив его в блок оператора synchronized и синхронизироваться по ссылке на созданный объект этого класса.

### Особенности реализации:
#### :warning: Без синхронизации сообщение, состоящее из "[" + переменной,содержащей текст сообщения + "]" произойдет рассинхронизация, т.к. потоки будут обращаться рандомно не дожидаясь завершения.

- Caller - класс реализующий интерфейс Runnable.
- Конструктор класса принимает ссылку на объект синхронизации(монитор) и текстовое сообщение.
- Метод run() содержит блок синхронизации, который производит синхронизацию по ссылке на объект класса CallMe в методе call() которого, выполняется логика формирования будущего сообщения.
- В классе "Main" создается объект синхронизации(ссылка на объект класса Callme), по нему проводится синхронизация в блоке synchronized класса потока Caller.
- Далее создается 3 объекта класса Caller(3 потока, генерирующих 3 сообщения), передается ссылка на объект синхронизации(монитор) и текстовое сообщение.

:warning: Для чистоты эксперемента есть смысл убрать из примера join-ы(хотя они и нужны лишь для правильной последвательности вывода сообщений), т.к они служат дополнительным синхронизатором, и не убрав их, но убрав блок синхронизации вы не увидете рассинхронного вывода сообщений.

**********************************************************************

:warning: **Не скупимся на звездочки на github, форкаем, даем советы по улучшению и оптимизации (всегда рад).**
